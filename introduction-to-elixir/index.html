<!DOCTYPE html>
<html lang='en-us'>
<head>
  <meta charset='utf-8'>
  <title>Introduction to Elixir - Presentation by Alan Peabody</title>
  <link rel='stylesheet' href='../css/reveal.min.css'>
  <link rel='stylesheet' href='../css/night.css' id='theme'>
  <link rel='stylesheet' href='../css/zenburn.css'>
  <link rel='stylesheet' href='../css/customizations.css'>
</head>
<body>
  <div class='reveal'>
    <div class='slides'>
      <section>
        <p>Introduction to</p>
        <h1>Elixir</h1>
        <p>and functional programming for the</p>
        <h2>Web</h2>
      </section>

      <section>
        <h2>Who am I?</h2>
        <p>Alan Peabody - Developer @ <a href='http://agilionapps.com/'>Agilion Apps</a></p>
        <p>Rubyist - JavaScripter - Clojurian - Elixir-er?</p>
        <p>Slides: <a href='http://alanpeabody.com/presentations/introduction-to-elixir'>http://alanpeabody.com/presentations/introduction-to-elixir</a></p>
      </section>

      <section>
        <h2>What is Elixir?</h2>
        <blockquote>
          Elixir is a functional meta-programming aware language built on top of the Erlang VM. It is a dynamic language with flexible syntax with macros support that leverages Erlang's abilities to build concurrent, distributed, fault-tolerant applications with hot code upgrades.
        </blockquote>
        <p class='attribution'>&mdash; <a href='http://elixir-lang.com'>elixir-lang.com</a></p>
      </section>

      <section>
        <section>
          <h2>Influences</h2>
        </section>

        <section>
          <h3>Erlang</h3>
          <ul>
            <li>Compiles to Erlang Bytecode</li>
            <li>Actor Model</li>
            <li>Message Passing, OTP</li>
            <li>Pattern matching</li>
            <li>Guards</li>
            <li>Hot code swapping</li>
          </ul>
        </section>

        <section>
          <h3>Ruby</h3>
          <p>Syntax</p>
          <pre><code>
defmodule Example do

  def do_something(variable) do
    IO.puts "Called Example.do_something(#{variable})"
  end

end
Example.do_something(:symbol)
          </code></pre>
        </section>

        <section>
          <h3>Clojure/Lisp</h3>
          <ul>
            <li>Macros</li>
            <li>Leiningen build tool</li>
            <li>Protocols</li>
            <li>Includes/Imports/Refers</li>
          </ul>
        </section>
      </section>

      <section>
        <section>
          <h2>Installation</h2>
        </section>

        <section>
          <h3>Install Erlang</h3>
          <p>Ubuntu</p>
          <pre><code class='bash'>
sudo apt-get install erlang
          </code></pre>
          <p>OS X</p>
          <pre><code class='bash'>
brew install erlang
          </code></pre>
        </section>
        <section>
          <h3>Install Elixir</h3>
          <p>Ubuntu</p>
          <pre><code class='bash'>
cd ~
git clone git://github.com/elixir-lang/elixir.git
cd elixir
git checkout v0.8.1
make
cat "$PATH=$PATH:$HOME/elixir/bin" >> ~/.zshrc
          </code></pre>
          <p>OS X</p>
          <pre><code class='bash'>
brew install elixir
          </code></pre>
        </section>
        <section>
          <h3>Install Rebar</h3>
          <p>Erlang build tool, for erlang library dependencies</p>
          <pre><code class='bash'>
# Assumes ~/bin is in your path
cd ~/bin
wget http://cloud.github.com/downloads/basho/rebar/rebar
chmod u+x rebar
          </code></pre>
        </section>
      </section>

      <section>
        <section>
          <h2>Our First Application</h2>
        </section>

        <section>
          <h3>Pascal</h3>
          <p>Building an Elixir application with OTP that returns Pascal's Triangles.</p>
          <pre>

                                         1
                                        1,1
                                       1,2,1
                                      1,3,3,1
                                     1,4,6,4,1

          </pre>
          <p>Mix, Ex:Unit, Guards, Recursion, OTP</p>
        </section>

        <section>
          <h3>Generating an application</h3>
          <pre><code class='bash'>
$ mix new pascal --sup
* creating README.md
* creating .gitignore
* creating mix.exs
* creating lib
* creating lib/pascal.ex
* creating lib/pascal
* creating lib/pascal/supervisor.ex
* creating test
* creating test/test_helper.exs
* creating test/pascal_test.exs
          </code></pre>
        </section>

        <section>
          <h3>Mix - Package Management and Build Tool</h3>
          <p><code>mix.exs</code></p>
          <pre><code class='ruby'>defmodule Pascal.Mixfile do
  use Mix.Project

  def project do
    [ app: :pascal,
      version: "0.0.1",
      deps: deps ]
  end

  # Configuration for the OTP application
  def application do
    [mod: { Pascal, [] }]
  end

  # Returns the list of dependencies in the format:
  # { :foobar, "0.1", git: "https://github.com/elixir-lang/foobar.git" }
  defp deps do
    []
  end
end </code></pre>
        </section>

        <section>
          <h3>Mix - Package Management and Build Tool</h3>
          <pre><code class='bash'>
$ mix do deps.get, test

> Compiled lib/pascal.ex
> Compiled lib/pascal/supervisor.ex
> Generated pascal.app
> .
> 1 test, 0 failures
          </code></pre>
          <pre><code class='bash'>
$ mix help
mix clean           # Clean generated application files
mix compile         # Compile source files
mix deps            # List dependencies and their status
mix deps.clean      # Remove dependencies files
mix deps.compile    # Compile dependencies
mix deps.get        # Get all out of date dependencies
mix deps.unlock     # Unlock the given dependencies
mix deps.update     # Update dependencies
mix do              # Executes the commands separated by comma
# ...
mix run             # Run the given expression
mix test            # Run a project's tests
          </code></pre>
        </section>

        <section>
          <h3>iex</h3>
          <p>Start an interactive Elixir repl/console, and include your application.</p>
          <pre><code class='bash'>
$ iex -S mix
          </code></pre>
          <pre><code class='ruby'>
iex(1)> IO.puts("Hello VTFun!")
Hello VTFun!
:ok
          </code></pre>
        </section>
      </section>

      <section>
        <section>
          <p>Stepping back</p>
          <h2>Elixir Syntax 101</h2>
        </section>


        <section>
          <h3>Strings</h3>
          <p>Elixir string are utf-8 binary strings.</p>
          <pre><code class='ruby'>
iex(1)> my_string = "§tring"
"§tring"
iex(2)> is_binary(my_string)
true
iex(3)> is_list("string")
false
iex(4)> world = "World"
"World!"
iex(5)> "Hello interpolated #{world}!"
"Hello interpolated World!"
iex(6)> String.split("Who,loves,CSVs?", ",")
["Who","Loves","CSVs?"]
          </code></pre>
          <aside class='notes'>
            <ul>
              <li>Utf 8 string</li>
              <li>first string Binding</li>
              <li>Erlang uses lists of characters</li>
            </ul>
          </aside>
        </section>

        <section>
          <h3>Numbers</h3>
          <pre><code class='ruby'>
iex(1)> 1 + 1
2
iex(2)> 1 + 2.0
3.0
iex(3)> 1/2
0.5
iex(4)> div 1, 2
0
iex(5)> 0 == 0.0
true
iex(6)> 0 === 0.0
false
<span class='fragment'>
iex(7)> 0 = 0
0</span></code></pre>
          <aside class='notes'>
            
          </aside>
        </section>

        <section>
          <h3>Atoms</h3>
          <p>Ruby <code>:symbols</code>, Clojure <code>:keywords</code>, Erlang <code>atoms</code></p>
          <pre><code class='ruby'>
iex(1)> my_symbol = :ok
:ok
<span class='fragment'>
iex(2)> :ok = my_symbol
:ok</span><span class='fragment'>
iex(3)> :ok = :ok
:ok</span><span class='fragment'>
iex(4)> :ok = :error
** (MatchError) no match of right hand side value: :error
iex(5)> :ok = "ok"
** (MatchError) no match of right hand side value: :error
          </code></pre>
          <aside class='notes'>
            
          </aside>
        </section>

        <section>
          <h3>Lists</h3>
          <p>Linked Lists</p>
          <pre><code class='ruby'>
iex(1)> is_list([1,2,3])
true
iex(2)> [head | tail] = [1,2,3]
[1,2,3]
iex(3)> head
1
iex(4)> tail
[2,3]
iex(5)> [4 | tail]
[4,2,3]
iex(6)> ["4" | tail]
["4",2,3]
iex(7)> length tail
2
          </code></pre>
          <aside class='notes'>
            
          </aside>
        </section>

        <section>
          <h3>Tuples</h3>
          <p>Stored contiguously in memory</p>
          <pre><code class='ruby'>
iex(1)> is_tuple({:ok, 200})
true
iex(2)> {status, code} = {:ok, 200}
{:ok,200}
iex(3)> status
:ok
iex(4)> code
200
iex(5)> {:ok, status, body} = {:ok, 200, "Hello World"}
{:ok,200,"Hello World"}
iex(6)> {:ok, status, body} = {:error, 500, "Application Error"}
** (MatchError) no match of right hand side value: {:error,500,"Application Error"}
iex(7)> tuple = {:at, 1, "a", "b", 2, :om}
{:at,1,"a","b",2,:om}
iex(8)> elem tuple, 2
"a"
iex(9)> setelem tuple, 2, "aardvark" # expensive, copies whole tuple
{:at,1,"aardvark","b",2,:om}
          </code></pre>
        </section>

        <section>
          <h3>Keyword Lists</h3>
          <p>Represented as a list of tuples, same as Erlang's <code>Orddict</code>.</p>
          <pre><code class='ruby'>
iex(1)> headers = [status: :ok, code: 200]
[status: :ok, code: 200]
iex(2)> [first | rest] = headers
[status: :ok, code: 200]
iex(3)> first
{:status,:ok}
iex(4)> options = [foo: "foo", bar: "bar", foo: "more foo!?"]
[foo: "foo", bar: "bar", foo: "more foo!?"]
iex(5)> options[:foo]
"foo"
iex(6)> Keyword.get(options, :foo)
"foo"
iex(7)> Keyword.get_values(options, :foo)
["foo","more foo!?"]
          </code></pre>
        </section>
      </section>

      <section>
        <section>
          <h2>Implementing Pascal</h2>
        </section>

        <section>
          <h3>The Triangle Module</h3>
          <div class='side-by-side'>
            <div class='left'>
              <p><code>test/pascal/triangle_test.exs</code></p>
              <pre><code class='ruby'>
Code.require_file "../../test_helper.exs", __FILE__

defmodule TriangleTest do
  use ExUnit.Case

  test "generating a triangle" do
    <span class='fragment' data-fragment-index="1">assert Pascal.Triangle.generate(0) == []
    assert Pascal.Triangle.generate(1) == [[0,1,0]]
    assert Pascal.Triangle.generate(2) == [[0,1,0],
                                           [0,1,1,0]]
    assert Pascal.Triangle.generate(3) == [[0,1,0],
                                           [0,1,1,0],
                                           [0,1,2,1,0]]</span>
  end

end
              </code></pre>
            </div>
            <div class='right'>
              <p><code>lib/pascal/triangle.ex</code></p>
              <pre><code class='ruby'>
defmodule Pascal.Triangle do
  <span class='fragment' data-fragment-index="2">
  def generate(0) do
    []
  end
  </span><span class='fragment' data-fragment-index="3">
  def generate(1) do
    [[0,1,0]]
  end
  </span><span class='fragment' data-fragment-index="3">
  def generate(2) do # Seriously?
    [[0,1,0],[0,1,1,0]]
  end
  </span>
end
              </code></pre>
            </div>
          </div>
        </section>

        <section>
          <h3>Recursion w/ Guards</h3>
          <pre><code class='ruby smaller'>
defmodule Pascal.Triangle do
  def generate(0) do
    []
  end
  <span class='fragment'>
  def generate(rows) do
    generate([[0,1,0]], rows, 1)
  end
  </span><span class='fragment'>
  defp generate(triangle, max, current) when max >= current do
    triangle
  end
  </span><span class='fragment'>
  defp generate(triangle, max, current) do
    generate([[0,1,0] | triangle], max, current + 1)
  end
  </span>
end
          </code></pre>
        </section>

        <section>
          <h3>Pascal's <strike>Triangle</strike> Rectangle!</h3>

          <pre><code class='bash'>
$ iex -S mix
          </code></pre>
          <pre><code class='ruby'>
iex(1)> Pascal.Triangle.generate(5)
[[0,1,0],
 [0,1,0],
 [0,1,0],
 [0,1,0],
 [0,1,0]]
          </code></pre>

        </section>

      </section>

      <section>
        <p>Bonus!</p>
        <h2>Dynamo</h2>
        <p>Elixir Web Development</p>
      </section>

      <section>
        <h2>Thank you!</h2>
        <p>Alan Peabody</p>
        <ul>
          <li>Twitter: <a href='http://twitter.com/alanpeabody'>@alanpeabody</a></li>
          <li>Github: <a href='http://github.com/alanpeabody'>alanpeabody</a></li>
          <li>Slides: <a href='http://alanpeabody.com/presentations/introduction-to-elixir'>http://alanpeabody.com/presentations/introduction-to-elixir</a></li>
        </ul>
      </section>

    </div>
  </div>

  <div class='progress'><span></span></div>

  <script src='../js/highlight.js'></script>
  <script src='../js/head.min.js'></script>
  <script src='../js/reveal.min.js'></script>
  <script src='../js/notes.js'></script>
  <script>
    Reveal.initialize({

      width: '90%',
      height: '100%',

      // Display controls in the bottom right corner
      controls: true,
      // Display a presentation progress bar
      progress: true,
      // Push each slide change to the browser history
      history: true,
      // Enable keyboard shortcuts for navigation
      keyboard: true,
      // Enable the slide overview mode
      overview: true,
      // Vertical centering of slides
      center: true,
      // Apply a 3D roll to links on hover
      rollingLinks: false,
      // Transition style
      transition: 'linear', // default/cube/page/concave/zoom/linear/fade/none
      theme: 'night',

      dependencies: [
        // Syntax highlight for <code> elements
        { src: '../js/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
        { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
      ]
    });
  </script>
</body>
</html>
